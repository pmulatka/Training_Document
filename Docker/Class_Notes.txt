
#########################
Day 18 : 23rd Sep. 2025
#########################


	--> Containerization using Docker ::::	
	
	Introduction :::
	
	
	Containerization ::::
	
		-> It is process of packaging the application along with its dependencies!
		
		
	Virtual Machine :::
	
		- VMs are called as Hardware Level Virtualization
		- VMs are created using Hypervisor
		- VMs are used to execute an Operating System 
		- VMs will continue to run even if there is not active Application/Task
		- VMs consume more Time and space to start any Application/Task	
		

	Container :::
	
		- Containers are called as OS Level Virtualization
		- Containers are created using Container Engine(Docker)
		- Containers are used to execute any Application/Task. Not Operating System 		
		- Containers will immediately go to exit state, if there is No active Application/Task		
		- Containers consume less Time and space to start any Application/Task	

		- Using Containers, we can reduce the no. of VMs. But we cannot completely eliminate VMs.
		
		- Containers use the properties of underlying Operating System
		
			Kernel			==> Is the core of Linux Operating 

				- Namespaces 				
				- Control Groups 
		

Next :::

				
	Working with Containerization :::
	
		-> Infra-Structure Management Perspectives :
		
		
		-> Developers' / Deployment Perspectives :
	
	Terminologies :::
	
		- Container Engine :::
		
				- To Create and Manage the Container
					
	
	
	Install and Using Docker :::
	


#########################
Day 19 : 25th Sep. 2025
#########################

	Kernel			==> Is the core of Linux Operating 
	
		Task --> Process. 
		
			- Process run in it's own address space 
			- Process ID 
			- Process Communication 
			- Inter-Process Communication
			- Process Volume

		- Namespaces 				
		- Control Groups 

	Containerization ::::
	
		-> It is process of packaging the application along with its dependencies!
				
				
	Working with Containerization :::
		
		-> Infra-Structure Management Perspectives :
		
			- It used to reduce the Infra-Structure Cost.
			- Using Containers, we can reduce the no. of VMs.
			
			
			Jenkins_Master (VM)				==> To Create Jenkins CI/CD Pipeline Jobs/Projects & Schedule to run in Jenkins_SlaveNode
											==> Install Git, JDK, Jenkins											
											
				Jenkins_SlaveNode1 (VM1)	==> Java Build Tools								
				Jenkins_SlaveNode2 (VM2)	==> Python
				Jenkins_SlaveNode3 (VM3)	==> .Net
				Jenkins_SlaveNode4 (VM4)	==> Angular/Nodejs
				Jenkins_SlaveNode5 (VM5)	==> Ruby
				
			Using Containerization ::
		
			Jenkins_Master (VM)				==> To Create Jenkins CI/CD Pipeline Jobs/Projects & Schedule to run in Jenkins_SlaveNode
											==> Install Git, JDK, Jenkins
				Jenkins_SlaveNode1 (VM)
					- Install Container Engine(Docker)
							C1 				==> Java Build Tools		
							C2              ==> Python
							C3              ==> .Net
							C4              ==> Angular/Nodejs
							C5              ==> Ruby
						
		
		-> Developers' / Deployment Perspectives :	
		

			Containerization ::::
			
				-> It is process of packaging the application along with its dependencies!
			
			Environments :
			
				Developer :	
					- Create Source Code 
					- Build and Create mywebapp.war
					- jdk17 & tomcat8
					
					- Run mywebapp.war using tomcat and perform Unit Testing in Local Machine 

					- Commit the Source_Code to GitHub Repos 
					
					- Create Application Image using (mywebapp.war,jdk17,tomcat8)	==> mywebapp_img:v1 (Package)
					
					- Application Image will be published to Container Registry(DockerHub)
							==> mywebapp_img:v1
							
							
				Version Control System :
				
				Dev/Build Process :
				
				Source_Code Repository(Github) 			Artifactory_Libraries(Jfrog)		Container Registry(DockerHub)
				
					mywebapp.java:v1						mywebapp.war:v1						mywebapp_img:v1
					mywebapp.java:v2						mywebapp.war:v2						mywebapp_img:v2
					mywebapp.java:v3						mywebapp.war:v3						mywebapp_img:v3
					mywebapp.java:v4						mywebapp.war:v4						mywebapp_img:v4					
					
					
				QA :		
					- Pull mywebapp_img:v1 from Container Registry(DockerHub) and Create a Application Container
					
					- Run Application Container and perform QA Level Testing  
				
			
				UAT :			
					- Pull mywebapp_img:v1 from Container Registry(DockerHub) and Create a Application Container
					
					- Run Application Container and perform UAT Level Testing   	

			
				PROD :			
					- Pull mywebapp_img:v1 from Container Registry(DockerHub) and Create a Application Container
					
					- Run Application Container and perform PROD Level Testing   	
		
		
	Terminologies/Components of Docker Architecture :::
	
		Container Engine 
			-- Is used to Create/Manage Container Images and Create/Manage and run Containers	
		
		Container Images 
			--	Is a Static file that defined the properties of the Container and its dependencies 
			--  Container Images are Non-Executables
			--  Container Images are composed of various Layers created using the Dockerfile Instructions
			
		Containers 
			--	Containers are the executable units of Container Images
			-- 	Containers are used to run the applications defined in the Container Images 		
		
		Container Registry 
			--	It is used to save and version control the Container Images 
				Dockerhub is Container Registry to be used.
				https://hub.docker.com/			
		
		Container Repositories
			--	Container Repositories	are the subset of Container Registry
			
			github 			Docker-Hub_Registry
				repo1			Docker-hub_Repository1
				repo2			Docker-hub_Repository2
				
				
				
	- Create DockerHub Account ::::
	
		- Login to DockerHub Account 
		- Explore the existing Docker Container Images 
		
	
	
	
	- Install Docker Engine in Local Machine :::		# https://docs.docker.com/engine/install/
	
		- Launch Ubuntu Machine - v22.04 / Use existing Jenkins Slave Node to Install Docker Engine
		
		- sudo -i 
		- apt update -y 			
		- apt install docker.io -y
		
		
	- Working Docker CLI Commands
		
		docker --version		
		
		docker images 			# To get the list of images in local machine 
		
		docker ps 				# To get the list of Active/Running Containers 
		
		docker ps -a			# To get the list of all containers
		
		

		docker pull <Image_Name>	# To download the docker container image from dockerhub registry to local machine 
		
			Eg.:
				docker pull centos:latest
				docker pull ubuntu:v1.0	
				docker pull nginx
				
		docker run <Image_Name>					# To Create and run a Container based on the image. 
		
		Container Execution Modes ::
	
			- Foreground / Attached Mode 		# Default Mode 
			
					docker run <image_name> 
					
					Eg.: 
					
						docker run ubuntu sleep 20 
			
			- Background / Detached Mode 
				
					docker run -d <image_name> 
					Eg.: 
					
						docker run -d ubuntu sleep 20 	



Next :::			
			- Interactive Mode 
			
			- Continue with Docker Cli Commands.....




#########################
Day 20 : 26th Sep. 2025
#########################

	Container Execution Modes ::

	Three Modes of Creating/Running the Containers:
	
		- Foreground / Attached Mode 		# Default Mode 
		
				docker run <image_name> 
				
				Eg.: 
				
					docker run ubuntu sleep 20 
		
		- Background / Detached Mode 
			
				docker run -d <image_name> 
				Eg.: 
				
					docker run -d ubuntu sleep 20 	
					
		- Interactive Mode 
		
				docker run -it <image_name> 
				Eg.: 
				
					docker run -it ubuntu bash 	
					
					exit							# Exit/stop the Container 
					
				
		- docker start <Container_ID> 			# Start the Container		
		
		- Login to Running Container :
		
			docker exec -it <Container_ID> bash 
			
			Eg.:
			
			docker exec -it 092dc9986518 bash
		
			exit 								# Log-off from the Container
			
		- docker stop <Container_ID> 			# Stop the Running Container 
		
		
		- Remove Containers & Images from Local Machine!
		
			- docker rmi <image_name>			# To Remove Container Images 
			
			- docker rm <Container_ID>			# To Remove Containers 	
			
			
		- Port Mapping/Binding :::
		
			- It is used to expose the Container Application to Internet.			
			
			docker run -it -p 8085:8080 tomcat:8.0 			
		
				-p <host_port>:<container_port>
			
				Access the Application running inside the container using port mapping :
			
				<external_ip_addr>:<host_port>
				
				43.204.233.96:8085 	
			
			
		- Docker Container Volume ::::
		
			
			Containers! used to run any task/application.
			
			By default, Containers are meant for Stateless Application 
			
			Stateful Application :
			
				- Leave some trace of execution in the form of logs/reports/output.
				- By default Container are not used to execute stateful application.
				
				
			- Docker Container Volumes are used to execute stateful applications and maintain the persistant data/volume.
			- Persistant Data/volume exist even after the life time of Containers
			
			
			3-Tier Application Architecture ????
			
				Sign_in Micro-Service
				
					- Front-End Layer	==> User Interaction ==> C1 
					
					- Application Layer	==> Business Logic	 ==> C2 
					
					- Back-End Layer	==> Database 		 ==> C3 
					
			- Container are basically used to execute application/task.			
			- Containers are actually used to run the stateless application.
			
			- This is to maintain pesistant data!	
			
		Stateless application :
		
			- Application that never retain the state of execution 
		
		Stateful application :
		
			- To work with the stateful applications, Docker Volumes can be used.
			
		- Create Docker Volumes & Mount to Containers
			
			docker volume list 					# List the Docker Volumes 
			
			docker volume create pl-vol1		# Create a docker volume 
			
			docker volume inspect pl-vol1		# Inpect/Get the Properties of Volume
			
			docker run -it --mount source=pl-vol1,destination=/pl-vol1 ubuntu bash  
			
			
	
	- Create Container Images :::
	
		Container Images 
			--	Is a Static file that defined the properties of the Container and its dependencies 
			--  Container Images are Non-Executables
			--  Container Images are composed of various Layers created using the Dockerfile Instructions		

Next ::::
			
		Commands used to create Docker Container Images :::
		
		
			- docker commit 
			- docker build 

		
	

#########################
Day 21 : 29th Sep. 2025
#########################		

	
	- Create Container Images :::
	
		Container Images 
			--	Is a Static file that defined the properties of the Container and its dependencies 
			--  Container Images are Non-Executables
			--  Container Images are composed of various Layers created using the Dockerfile Instructions			
		
		

		Container Registry 
			--	It is used to save and version control the Container Images 
				Dockerhub is Container Registry to be used.
				https://hub.docker.com/			
		
		Container Repositories
			--	Container Repositories	are the subset of Container Registry
			
			github 			Docker-Hub_Registry
				repo1			Docker-hub_Repository1
				repo2			Docker-hub_Repository2

				
	Create Container Images :::
	
	- Docker commit :::
		
		=> To Create a New Container Image based on the properties of existing Container.
		
			Syntax :

				docker commit <existing_container_id> <dockerhub_repo_name>/New_Image_Name>:<tag_Name>
				
				Eg.: 
				
					docker commit 3af035ab37d8 loksaieta/pl-javabuild-img:v1.0
				

	- Docker Push :
	
		=> To Push the Image to Container Registry 
		
		=> Create Personel Access Token in Dockerhub registry :::
		
				docker login -u loksaieta
			
				sadfasdfeascqaassd
			
		
			docker push loksaieta/pl-javabuild-img:v1.0
			

	- Docker Build :
	
		- To create a new Container Image based on the Dockerfile reference.
		- Dockerfile composed of Instructions to Create Docker Container Images
		- Application Developers create the Dockerfile and update in the Source Code Repository. 
		
			Syntax :
			
			docker build -t <dockerhub_repo_name>/New_Image_Name>:<tag_Name> .		# '.' refers to the Dockerfile path
			
			Eg.: 
			
			docker build -t loksaieta/pl-appbuild-img .	# '.' refers to the Dockerfile path	

		vi Dockerfile 
		
			FROM ubuntu
			RUN apt update -y
			RUN apt install git -y 
			RUN apt install maven -y 
			
			
		Dockerfile Instructions :
		
		FROM 			# This is identify the base Image 
		
		RUN				# To execute any package manager

		COPY 			# To Copy the files from host volume to container volume 
		
		CP				# To Copy the files within the Container Volume 
		
		ADD 			# To Copy/Download the files from external URLs to Container Volume 

		EXPOSE			# To set the Container Port.
		
		WORKDIR			# To Set the Current Working Directory
		
		CMD				# To Set the default Start-up Task to start a Container 
						# The Start-up Task can be Modified at the time of Container Creation 
						
		ENTRYPOINT		# To Set the default Start-up Task to start a Container 
						# The Start-up Task cannot be Modified at the time of Container Creation 		



		Eg.: 
		
			Containerize the web application using docker build command.
			
		vi Dockerfile 
		
		FROM tomcat:8.0
		COPY ./target/*.war /usr/local/tomcat/webapps
		EXPOSE 8080		
	
	
	- Add devopsadmin user to docker group :
	
		usermod -aG docker devopsadmin		
	
	- docker build -t loksaieta/myweapp .	# '.' refers to the Dockerfile path	
		
		
		
	- Container Orchestration ::::
	
		- This to ensure high availability of Containers ::::
		
		3-Tier Application Architecture ????
		
			Sign_in Micro-Service
			
				- Front-End Layer	==> User Interaction ==> C1 
				
				- Application Layer	==> Business Logic	 ==> C2 
				
				- Back-End Layer	==> Database 		 ==> C3 
				
				
		- Docker Compose :::
		
			- Docker Compose is an additional plugin to Docker Engine
			- It is used to run more than once Container as a Service!
			
			- Used Docker Compose all the Containers can be started/Stopped at a same time to access as a Service.
			
			
Next :::

	Work with Docker Compose!
	
	Overview Docker Swarm 
	
	Docker Swarm vs Kubernetes
	
	Enhance CICD Pipeline using Docker.
	
	
	Kubernetes Module!
			

			
#########################
Day 22 : 30th Sep. 2025
#########################		


	Work with Docker Compose!
							
	- Docker Compose :::
	
		- Docker Compose is an additional plugin to Docker Engine
		- It is used to run more than once Container as a Service!
		- DockerCompose.yaml ==> To define the properties of the Containers to run as a service!

		
		- Used Docker Compose all the Containers can be started/Stopped at a same time to access as a Service.
	
		3-Tier Application Architecture ????
		
			Sign_in Micro-Service
			
				- Front-End Layer	==> User Interaction ==> C1 
				
				- Application Layer	==> Business Logic	 ==> C2 
				
				- Back-End Layer	==> Database 		 ==> C3 	
		
			Any Container that is part of a Service :
		
				should be in-sync with other container within the service 
				
				
				Start/Stop all these container at the same time.
		
		
		
		Work with Docker Compose ::
		
			Install Docker_Compose :::
			
			https://docs.docker.com/compose/
			
			https://docs.docker.com/compose/install/linux/
			
			https://docs.docker.com/compose/install/linux/#install-the-plugin-manually
			
			
			
# Manual Installation of Docker Compose :::
			
DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
mkdir -p $DOCKER_CONFIG/cli-plugins
curl -SL https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose

chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
	
docker compose version

vi docker-compose.yaml



### Yaml Files are based on Keys & Values -- key:value Pairs

version: '3'
services:
  webserv1:
    image: "tomcat:8.0"
    ports:
      - 8098:8080
  dbserv1:
    image: "redis:alpine"
	
docker compose up 

docker compose down 


	Service :
	
		C1.1,1.2,1.3
		
		C2.1.2.2,2.3 

	E_Commerce Application:
	
		Prod_Server 	-->  10000 Users 		---> 	10 Servers
							 20000 Users 		--->	Scale the Servers	

VM :

	Environments :
	
	Non-Prod							Prod Environment  
	
		Dev 
		
		QA 
		
		UAT 			==========>			Prod Server1,2,3,4,5
		
		
	Container Orchestration Tool : Docker Swarm 
		
	- Docker Swarm ::::
	
		- Docker Swarm is one the Container Orchestration Tools.
		- It is meant only for Docker Containers.
		- Used to Ensure High Availability of Containers by creating Replicas of Containers.
		
		- We cannot do Auto-Scaling or Load Balancing!			

		3-Tier Application Service :	
				
			User_SignIn Service :		
				
				Front-End			-->		c1.0,1.1,1.2		
						
				Application_Layer 	-->		c2.0,2.1,2.2			
						
				Database Layer 		-->		c3.0,3.1,3.2	


	- Kubernetes ::::
	
		- It is an Open-Source Container Orchestration Tool 
		- Kubernetes is used to Deploy any type of Containers.
		- It is used to ensure high availability of the Applications/services running thru Containers.
		- Used to Ensure High Availability of Containers by creating Replicas of Containers.
		- It supports Auto-Scaling & Load Balancing.
		- It perform self healing.
		
		
		AWS : 	ECS,ECR,EKS 
		
		Azure: 	ACS,ACR,AKS

		GCP:	GCE,GCR,GKE
		

	DevOps ::::
		
		- Create CICD Pipeline to automate Application Build and Containerization.


		- Stages of CI/CD Pipeline:
		
			-> git clone 	===> SCM_Checkout								git/github
			
			-> Application Build using Maven 								maven 
			
			-> Unit Testing using Maven &  Junit 							maven & junit 
			
			-> Create Artifacts using Maven									maven  
			
			-> Promote the Application Artifacts to Target Environment 		Ansible/SSH Plugins/Docker/Kubernetes
			
			-> Send Email Notifications to the Teams using Email Server 	Email Servers 
			
			-> Target Environment : QA/UAT/Prod 


		- CI-CD Pipeline for Containerized Application Service :
		
		
		Stages :
		
			- SCM_Checkout
			- Application_Build(mvn clean package)			# *.war 
			- Application Image Build 		
			- Login to Container Registry(DockerHub)
			- Push the Application Image to Container Registry(DockerHub)
			
			
			
			- Deploy Application Images to Target Environment using Kubernetes.					 # Upon Kubernetes Module.
			
			
		How to Implement this?
		
		
		Resources :::
		
			- Servers :
			
				- Jenkins_Master(VM)		:	Purpose: To Create CICD Pipeline Projects and schedule to run in the build nodes.
					Jenkins_SlaveNode1(VM)	: 	Purpose: To run the Application Build and Application Image Build
														 Publish the Application Image to Container Registry.
				
			- Tools :
			
				- Jenkins_Master(VM)		: 	Tools:	git,jdk,jenkins(8080)
					Jenkins_SlaveNode1(VM)	:	Tools:	git,jdk,maven,docker
			
			
			- External/Internal Dependencies :			
			
				- Create DockerHub Access Token
			
				- Configure DockerHub Access Token in Jenkins Credential Manager 
		
		
				=> Create Personel Access Token in Dockerhub registry :::
				
						docker login -u loksaieta
					
						dkkjhkhkjhkko				


				- Add devopsadmin user to docker group :
				
					usermod -aG docker devopsadmin	


		
		Create CI Pipeline :
		
		Stages :
		
			- SCM_Checkout
			- Application_Build 
			- Application Image_Build 
			- Login to DockerHub 
			- Push the Application Image to DockerHub
			
		
													
pipeline {
    agent { label 'slave1' }

	environment {	
		DOCKERHUB_CREDENTIALS=credentials('dockerloginid')
	}

    stages {
        stage('SCM_Checkout') {
            steps {
                echo 'Perform SCM Checkout'
				git 'https://github.com/PL-DevOps-GenAI-0825/java-webapp-project.git'			
            }
        }
        stage('Application Build') {
            steps {
                echo 'Perform Application Build'
				sh 'mvn clean package'
            }
        }
        stage('Application Image Build') {
            steps {
                echo 'Perform Application Image Build'
				sh "docker build -t loksaieta/pljavawebapp:${BUILD_NUMBER} ."
            }
        }
        stage('Login to DockerHub') {
            steps {
                echo 'Login to DockerHub'
				sh 'echo $DOCKERHUB_CREDENTIALS_PSW | docker login -u $DOCKERHUB_CREDENTIALS_USR --password-stdin'
				
            }
        }
        stage('Push to DockerHub') {
            steps {
                echo 'Push Image to DockerHub'
				sh "docker push loksaieta/pljavawebapp:${BUILD_NUMBER}"
            }
        }
    }
}		
		

Next :

		Kubernetes!
